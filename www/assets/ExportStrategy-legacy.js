System.register(["./index-legacy.js","./Bitmap-legacy.js"],(function(t,e){"use strict";var i,o,s,a,r,n,h,p,d,c,l,m,u,g,y;return{setters:[t=>{i=t.a9,o=t.v,s=t.x,a=t.y,r=t.z,n=t.bm,h=t.A,p=t.at,d=t.aa,c=t.bx,l=t.d9,m=t.dU,u=t.bE,g=t.k},t=>{y=t.b}],execute:function(){const e=Math.PI/180;function x(t){return t*e}function f(t,e){const i=x(e.rotation),o=Math.abs(Math.cos(i)),s=Math.abs(Math.sin(i)),[a,r]=e.size;return t[0]=Math.round(r*s+a*o),t[1]=Math.round(r*o+a*s),t}const v=i(),M=[0,0],_=new o(0,0,0,0),S=2048,w=2048,P=!1,R=!1,b=!1;let z=class extends n{constructor(t){super(t),this._imagePromise=null,this.bitmaps=[],this.hidpi=b,this.imageMaxWidth=S,this.imageMaxHeight=w,this.imageRotationSupported=P,this.imageNormalizationSupported=R,this.update=h((async(t,e)=>{if(p(e),!t.stationary||this.destroyed)return;const i=t.state,o=d(i.spatialReference),s=this.hidpi?t.pixelRatio:1,a=this.imageNormalizationSupported&&i.worldScreenWidth&&i.worldScreenWidth<i.size[0],r=this.imageMaxWidth??0,n=this.imageMaxHeight??0;a?(M[0]=i.worldScreenWidth,M[1]=i.size[1]):this.imageRotationSupported?(M[0]=i.size[0],M[1]=i.size[1]):f(M,i);const h=Math.floor(M[0]*s)>r||Math.floor(M[1]*s)>n,l=o&&(i.extent.xmin<o.valid[0]||i.extent.xmax>o.valid[1]),m=!this.imageNormalizationSupported&&l,u=!h&&!m,g=this.imageRotationSupported?i.rotation:0,y=this.container.children.slice();if(u){const t=a?i.paddedViewState.center:i.center;this._imagePromise&&console.error("Image promise was not defined!"),this._imagePromise=this._singleExport(i,M,t,i.resolution,g,s,e)}else{let t=Math.min(r,n);m&&(t=Math.min(i.worldScreenWidth,t)),this._imagePromise=this._tiledExport(i,t,s,e)}try{const t=await this._imagePromise??[];p(e);const i=[];if(this._imagePromise=null,this.destroyed)return;this.bitmaps=t;for(const e of y)t.includes(e)||i.push(e.fadeOut().then((()=>{e.remove(),e.destroy()})));for(const e of t)i.push(e.fadeIn());await Promise.all(i)}catch(_){this._imagePromise=null,c(_)}}),5e3),this.updateExports=h((async t=>{const e=[];for(const i of this.container.children){if(!i.visible||!i.stage)return;e.push(t(i).then((()=>{i.invalidateTexture(),i.requestRender()})))}this._imagePromise=l(e).then((()=>this._imagePromise=null)),await this._imagePromise}))}destroy(){this.bitmaps.forEach((t=>t.destroy())),this.bitmaps=[]}get updating(){return!this.destroyed&&null!==this._imagePromise}async _export(t,e,i,o,s,a){const r=await this.fetchSource(t,Math.floor(e*s),Math.floor(i*s),{rotation:o,pixelRatio:s,signal:a});p(a);const n=new y(null,!0);return n.x=t.xmin,n.y=t.ymax,n.resolution=t.width/e,n.rotation=o,n.pixelRatio=s,n.opacity=0,this.container.addChild(n),await n.setSourceAsync(r,a),p(a),n}async _singleExport(t,e,i,o,s,a,r){!function(t,e,i,o){const[s,a]=e,[r,n]=o,h=.5*i;t[0]=s-h*r,t[1]=a-h*n,t[2]=s+h*r,t[3]=a+h*n}(v,i,o,e);const n=m(v,t.spatialReference);return[await this._export(n,e[0],e[1],s,a,r)]}_tiledExport(t,e,i,o){const s=u.create({size:e,spatialReference:t.spatialReference,scales:[t.scale]}),a=new g(s),r=a.getTileCoverage(t);if(!r)return null;const n=[];return r.forEach(((s,r,h,p)=>{_.set(s,r,h,0),a.getTileBounds(v,_);const d=m(v,t.spatialReference);n.push(this._export(d,e,e,0,i,o).then((t=>(0!==p&&(_.set(s,r,h,p),a.getTileBounds(v,_),t.x=v[0],t.y=v[3]),t))))})),Promise.all(n)}};s([a()],z.prototype,"_imagePromise",void 0),s([a()],z.prototype,"bitmaps",void 0),s([a()],z.prototype,"container",void 0),s([a()],z.prototype,"fetchSource",void 0),s([a()],z.prototype,"hidpi",void 0),s([a()],z.prototype,"imageMaxWidth",void 0),s([a()],z.prototype,"imageMaxHeight",void 0),s([a()],z.prototype,"imageRotationSupported",void 0),s([a()],z.prototype,"imageNormalizationSupported",void 0),s([a()],z.prototype,"requestUpdate",void 0),s([a()],z.prototype,"updating",null),z=s([r("esri.views.2d.layers.support.ExportStrategy")],z),t("v",z)}}}));
