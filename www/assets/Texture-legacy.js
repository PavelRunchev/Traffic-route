System.register(["./index-legacy.js","./enums-legacy.js"],(function(e,t){"use strict";var r,i,s,a,n,o,c,l,_,h,u,d,p;return{setters:[e=>{r=e.ai,i=e.s,s=e.w},e=>{a=e.C,n=e.c,o=e.P,c=e.B,l=e.G,_=e.M,h=e.U,u=e.L,d=e.D,p=e.V}],execute:function(){e({E:function(e,t,r,i,s=0){const a=e.gl;e.bindBuffer(r);for(const n of i){const r=t.get(n.name);if(void 0===r){console.warn(`There is no location for vertex attribute '${n.name}' defined.`);continue}const i=s*n.stride;if(n.count<=4)a.vertexAttribPointer(r,n.count,n.type,n.normalized,n.stride,n.offset+i),a.enableVertexAttribArray(r),n.divisor>0&&e.gl.vertexAttribDivisor(r,n.divisor);else if(9===n.count)for(let t=0;t<3;t++)a.vertexAttribPointer(r+t,3,n.type,n.normalized,n.stride,n.offset+12*t+i),a.enableVertexAttribArray(r+t),n.divisor>0&&e.gl.vertexAttribDivisor(r+t,n.divisor);else if(16===n.count)for(let t=0;t<4;t++)a.vertexAttribPointer(r+t,4,n.type,n.normalized,n.stride,n.offset+16*t+i),a.enableVertexAttribArray(r+t),n.divisor>0&&e.gl?.vertexAttribDivisor(r+t,n.divisor);else console.error("Unsupported vertex attribute element count: "+n.count);if(m()){const t=A(e),r=g(n.type),s=n.offset,a=Math.round(r/s)!==r/s?`. Offset not a multiple of stride. DataType requires ${r} bytes, but descriptor has an offset of ${s}`:"";t&&console.error(`Unable to bind vertex attribute "${n.name}" with baseInstanceOffset ${i}${a}:`,t,n)}}},a:I,c:m,d:function(){return E},o:A,s:g,u:T});const t=()=>s.getLogger("esri.views.webgl.checkWebGLError"),E=!!r("enable-feature:webgl-debug");function m(){return E}function T(e){if(m()){const r=e.getError();if(r){const s=function(e,t){switch(t){case e.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case e.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case e.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case e.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case e.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case e.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}(e,r),a=(new Error).stack;t().error(new i("webgl-error","WebGL error occurred",{message:s,stack:a}))}}}var R;function g(e){switch(e){case a.BYTE:case a.UNSIGNED_BYTE:return 1;case a.SHORT:case a.UNSIGNED_SHORT:return 2;case a.FLOAT:case a.INT:case a.UNSIGNED_INT:return 4}}function A(e){const t=e.gl;switch(t.getError()){case t.NO_ERROR:return null;case t.INVALID_ENUM:return"An unacceptable value has been specified for an enumerated argument";case t.INVALID_VALUE:return"An unacceptable value has been specified for an argument";case t.INVALID_OPERATION:return"The specified command is not allowed for the current state";case t.INVALID_FRAMEBUFFER_OPERATION:return"The currently bound framebuffer is not framebuffer complete";case t.OUT_OF_MEMORY:return"Not enough memory is left to execute the command";case t.CONTEXT_LOST_WEBGL:return"WebGL context is lost"}return"Unknown error"}function I(e){switch(e){case l.ALPHA:case l.LUMINANCE:case l.RED:case l.RED_INTEGER:case o.R8:case o.R8I:case o.R8UI:case o.R8_SNORM:case c.STENCIL_INDEX8:return 1;case l.LUMINANCE_ALPHA:case l.RG:case l.RG_INTEGER:case o.RGBA4:case o.R16F:case o.R16I:case o.R16UI:case o.RG8:case o.RG8I:case o.RG8UI:case o.RG8_SNORM:case o.RGB565:case o.RGB5_A1:case c.DEPTH_COMPONENT16:return 2;case l.DEPTH_COMPONENT:case l.RGB:case l.RGB_INTEGER:case o.RGB8:case o.RGB8I:case o.RGB8UI:case o.RGB8_SNORM:case o.SRGB8:case c.DEPTH_COMPONENT24:return 3;case l.DEPTH_STENCIL:case l.DEPTH24_STENCIL8:case l.RGBA:case l.RGBA_INTEGER:case o.RGBA8:case o.R32F:case o.R11F_G11F_B10F:case o.RG16F:case o.R32I:case o.R32UI:case o.RG16I:case o.RG16UI:case o.RGBA8I:case o.RGBA8UI:case o.RGBA8_SNORM:case o.SRGB8_ALPHA8:case o.RGB9_E5:case o.RGB10_A2UI:case o.RGB10_A2:case c.DEPTH_STENCIL:case c.DEPTH_COMPONENT32F:case c.DEPTH24_STENCIL8:return 4;case c.DEPTH32F_STENCIL8:return 5;case o.RGB16F:case o.RGB16I:case o.RGB16UI:return 6;case o.RG32F:case o.RG32I:case o.RG32UI:case o.RGBA16F:case o.RGBA16I:case o.RGBA16UI:return 8;case o.RGB32F:case o.RGB32I:case o.RGB32UI:return 12;case o.RGBA32F:case o.RGBA32I:case o.RGBA32UI:return 16;case n.COMPRESSED_RGB_S3TC_DXT1_EXT:case n.COMPRESSED_RGBA_S3TC_DXT1_EXT:return.5;case n.COMPRESSED_RGBA_S3TC_DXT3_EXT:case n.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case n.COMPRESSED_R11_EAC:case n.COMPRESSED_SIGNED_R11_EAC:case n.COMPRESSED_RGB8_ETC2:case n.COMPRESSED_SRGB8_ETC2:case n.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case n.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return.5;case n.COMPRESSED_RG11_EAC:case n.COMPRESSED_SIGNED_RG11_EAC:case n.COMPRESSED_RGBA8_ETC2_EAC:case n.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}e("b",R),function(e){e[e.Texture=0]="Texture",e[e.RenderBuffer=1]="RenderBuffer"}(R||e("b",R={}));class f{constructor(e=0,t=e){this.width=e,this.height=t,this.target=_.TEXTURE_2D,this.pixelFormat=l.RGBA,this.dataType=h.UNSIGNED_BYTE,this.samplingMode=u.LINEAR,this.wrapMode=d.REPEAT,this.maxAnisotropy=1,this.flipped=!1,this.hasMipmap=!1,this.isOpaque=!1,this.unpackAlignment=4,this.preMultiplyAlpha=!1,this.depth=1,this.isImmutable=!1}}e("e",f);class x extends f{constructor(e,t){switch(super(),this.context=e,Object.assign(this,t),this.internalFormat){case o.R16F:case o.R16I:case o.R16UI:case o.R32F:case o.R32I:case o.R32UI:case o.R8_SNORM:case o.R8:case o.R8I:case o.R8UI:this.pixelFormat=l.RED}}static validate(e,t){return new x(e,t)}}let M=e("m",class e{constructor(e,t=null,r=null){if(this.type=R.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,"context"in e)this._descriptor=e,r=t;else{const r=x.validate(e,t);if(!r)throw new i("Texture descriptor invalid");this._descriptor=r}this._descriptor.target===_.TEXTURE_CUBE_MAP?this._setDataCubeMap(r):this.setData(r)}get glName(){return this._glName}get descriptor(){return this._descriptor}get usedMemory(){return function(e){return e.width<=0||e.height<=0?0:Math.round(e.width*e.height*(e.hasMipmap?4/3:1)*(null==e.internalFormat?4:I(e.internalFormat)))}(this._descriptor)}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}dispose(){this._glName&&this._descriptor.context.instanceCounter.decrement(p.Texture,this),this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(e,t){const r=this._descriptor;if(r.width!==e||r.height!==t){if(this._wasImmutablyAllocated)throw new i("Immutable textures can't be resized!");r.width=e,r.height=t,this._descriptor.target===_.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(e=null){for(let t=_.TEXTURE_CUBE_MAP_POSITIVE_X;t<=_.TEXTURE_CUBE_MAP_NEGATIVE_Z;t++)this._setData(e,t)}setData(e){this._setData(e)}_setData(t,r){if(!this._descriptor.context?.gl)return;const s=this._descriptor.context.gl;T(s),this._glName||(this._glName=s.createTexture(),this._glName&&this._descriptor.context.instanceCounter.increment(p.Texture,this)),void 0===t&&(t=null);const a=this._descriptor,o=r??a.target,c=b(o);null===t&&(a.width=a.width||4,a.height=a.height||4,c&&(a.depth=a.depth??1));const l=this._descriptor.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),N(a),this._configurePixelStorage(),T(s);const _=this._deriveInternalFormat();if(U(t)){let e="width"in t?t.width:t.codedWidth,r="height"in t?t.height:t.codedHeight;const i=1;t instanceof HTMLVideoElement&&(e=t.videoWidth,r=t.videoHeight),a.width&&a.height,c&&a.depth,a.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(o,_,a.hasMipmap,e,r,i),this._texImage(o,0,_,e,r,i,t),T(s),a.hasMipmap&&this.generateMipmap(),a.width||(a.width=e),a.height||(a.height=r),c&&!a.depth&&(a.depth=i)}else{const{width:e,height:r,depth:l}=a;if(null==e||null==r)throw new i("Width and height must be specified!");if(c&&null==l)throw new i("Depth must be specified!");if(a.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(o,_,a.hasMipmap,e,r,l),P(t)){const c=t.levels,h=w(o,e,r,l),u=Math.min(h-1,c.length-1);s.texParameteri(a.target,this._descriptor.context.gl.TEXTURE_MAX_LEVEL,u);const d=_;if(!function(e){return e in n}(d))throw new i("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel(((e,t,r,i)=>{const s=c[Math.min(e,c.length-1)];this._compressedTexImage(o,e,d,t,r,i,s)}),u)}else this._texImage(o,0,_,e,r,l,t),T(s),a.hasMipmap&&this.generateMipmap()}D(s,this._descriptor),S(s,this._descriptor),function(e,t){const r=e.capabilities.textureFilterAnisotropic;r&&e.gl.texParameterf(t.target,r.TEXTURE_MAX_ANISOTROPY,t.maxAnisotropy??1)}(this._descriptor.context,this._descriptor),T(s),this._descriptor.context.bindTexture(l,e.TEXTURE_UNIT_FOR_UPDATES)}updateData(t,r,s,a,n,o,c=0){o||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const l=this._descriptor,_=this._deriveInternalFormat(),{context:h,pixelFormat:u,dataType:d,target:p,isImmutable:E}=l;if(E&&!this._wasImmutablyAllocated)throw new i("Cannot update immutable texture before allocation!");const m=h.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES,!0);(r<0||s<0||a>l.width||n>l.height||r+a>l.width||s+n>l.height)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:T}=h;c&&T.pixelStorei(T.UNPACK_SKIP_ROWS,c),U(o)?T.texSubImage2D(p,t,r,s,a,n,u,d,o):P(o)?T.compressedTexSubImage2D(p,t,r,s,a,n,_,o.levels[t]):T.texSubImage2D(p,t,r,s,a,n,u,d,o),c&&T.pixelStorei(T.UNPACK_SKIP_ROWS,0),h.bindTexture(m,e.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(t,r,s,a,n,o,c,l){l||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const _=this._descriptor,h=this._deriveInternalFormat(),{context:u,pixelFormat:d,dataType:p,isImmutable:E,target:m}=_;if(E&&!this._wasImmutablyAllocated)throw new i("Cannot update immutable texture before allocation!");b(m)||console.warn("Attempting to set 3D texture data on a non-3D texture");const T=u.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);u.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),(r<0||s<0||a<0||n>_.width||o>_.height||c>_.depth||r+n>_.width||s+o>_.height||a+c>_.depth)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:R}=u;if(P(l))l=l.levels[t],R.compressedTexSubImage3D(m,t,r,s,a,n,o,c,h,l);else{const e=l;R.texSubImage3D(m,t,r,s,a,n,o,c,d,p,e)}u.bindTexture(T,e.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const t=this._descriptor;if(!t.hasMipmap){if(this._wasImmutablyAllocated)throw new i("Cannot add mipmaps to immutable texture after allocation");t.hasMipmap=!0,this._samplingModeDirty=!0,N(t)}t.samplingMode===u.LINEAR?(this._samplingModeDirty=!0,t.samplingMode=u.LINEAR_MIPMAP_NEAREST):t.samplingMode===u.NEAREST&&(this._samplingModeDirty=!0,t.samplingMode=u.NEAREST_MIPMAP_NEAREST);const r=this._descriptor.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(t.target),this._descriptor.context.bindTexture(r,e.TEXTURE_UNIT_FOR_UPDATES)}setSamplingMode(e){e!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=e,this._samplingModeDirty=!0)}setWrapMode(e){e!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=e,N(this._descriptor),this._wrapModeDirty=!0)}applyChanges(){const e=this._descriptor,t=e.context.gl;this._samplingModeDirty&&(D(t,e),this._samplingModeDirty=!1),this._wrapModeDirty&&(S(t,e),this._wrapModeDirty=!1)}_deriveInternalFormat(){if(null!=this._descriptor.internalFormat)return this._descriptor.internalFormat===l.DEPTH_STENCIL&&(this._descriptor.internalFormat=l.DEPTH24_STENCIL8),this._descriptor.internalFormat;switch(this._descriptor.dataType){case h.FLOAT:switch(this._descriptor.pixelFormat){case l.RGBA:return this._descriptor.internalFormat=o.RGBA32F;case l.RGB:return this._descriptor.internalFormat=o.RGB32F;default:throw new i("Unable to derive format")}case h.UNSIGNED_BYTE:switch(this._descriptor.pixelFormat){case l.RGBA:return this._descriptor.internalFormat=o.RGBA8;case l.RGB:return this._descriptor.internalFormat=o.RGB8}}return this._descriptor.internalFormat=this._descriptor.pixelFormat===l.DEPTH_STENCIL?l.DEPTH24_STENCIL8:this._descriptor.pixelFormat}_configurePixelStorage(){const e=this._descriptor.context.gl,{unpackAlignment:t,flipped:r,preMultiplyAlpha:i}=this._descriptor;e.pixelStorei(e.UNPACK_ALIGNMENT,t),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,r?1:0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i?1:0)}_texStorage(e,t,r,s,a,n){const{gl:c}=this._descriptor.context;if(!function(e){return e in o}(t))throw new i("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const l=r?w(e,s,a,n):1;if(b(e)){if(null==n)throw new i("Missing depth dimension for 3D texture upload");c.texStorage3D(e,l,t,s,a,n)}else c.texStorage2D(e,l,t,s,a);this._wasImmutablyAllocated=!0}_texImage(e,t,r,s,a,n,o){const c=this._descriptor.context.gl,l=b(e),{isImmutable:_,pixelFormat:h,dataType:u}=this._descriptor;if(_){if(null!=o){const r=o;if(l){if(null==n)throw new i("Missing depth dimension for 3D texture upload");c.texSubImage3D(e,t,0,0,0,s,a,n,h,u,r)}else c.texSubImage2D(e,t,0,0,s,a,h,u,r)}}else{const _=o;if(l){if(null==n)throw new i("Missing depth dimension for 3D texture upload");c.texImage3D(e,t,r,s,a,n,0,h,u,_)}else c.texImage2D(e,t,r,s,a,0,h,u,_)}}_compressedTexImage(e,t,r,s,a,n,o){const c=this._descriptor.context.gl,l=b(e);if(this._descriptor.isImmutable){if(null!=o)if(l){if(null==n)throw new i("Missing depth dimension for 3D texture upload");c.compressedTexSubImage3D(e,t,0,0,0,s,a,n,r,o)}else c.compressedTexSubImage2D(e,t,0,0,s,a,r,o)}else if(l){if(null==n)throw new i("Missing depth dimension for 3D texture upload");c.compressedTexImage3D(e,t,r,s,a,n,0,o)}else c.compressedTexImage2D(e,t,r,s,a,0,o)}_forEachMipmapLevel(e,t=1/0){let{width:r,height:s,depth:a,hasMipmap:n,target:o}=this._descriptor;const c=o===_.TEXTURE_3D;if(null==r||null==s||c&&null==a)throw new i("Missing texture dimensions for mipmap calculation");for(let i=0;e(i,r,s,a),n&&(1!==r||1!==s||c&&1!==a)&&!(i>=t);++i)r=Math.max(1,r>>1),s=Math.max(1,s>>1),c&&(a=Math.max(1,a>>1))}});function N(e){(null!=e.width&&e.width<0||null!=e.height&&e.height<0||null!=e.depth&&e.depth<0)&&console.error("Negative dimension parameters are not allowed!")}function D(e,t){let r=t.samplingMode,i=t.samplingMode;r===u.LINEAR_MIPMAP_NEAREST||r===u.LINEAR_MIPMAP_LINEAR?(r=u.LINEAR,t.hasMipmap||(i=u.LINEAR)):r!==u.NEAREST_MIPMAP_NEAREST&&r!==u.NEAREST_MIPMAP_LINEAR||(r=u.NEAREST,t.hasMipmap||(i=u.NEAREST)),e.texParameteri(t.target,e.TEXTURE_MAG_FILTER,r),e.texParameteri(t.target,e.TEXTURE_MIN_FILTER,i)}function S(e,t){"number"==typeof t.wrapMode?(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode)):(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode.s),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode.t))}function P(e){return null!=e&&"type"in e&&"compressed"===e.type}function U(e){return null!=e&&!P(e)&&!function(e){return null!=e&&"byteLength"in e}(e)}function b(e){return e===_.TEXTURE_3D||e===_.TEXTURE_2D_ARRAY}function w(e,t,r,i=1){let s=Math.max(t,r);return e===_.TEXTURE_3D&&(s=Math.max(s,i)),Math.round(Math.log(s)/Math.LN2)+1}M.TEXTURE_UNIT_FOR_UPDATES=0}}}));
