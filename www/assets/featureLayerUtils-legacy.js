System.register(["./index-legacy.js","./originUtils-legacy.js","./utils-legacy.js","./fetchService-legacy.js","./lazyLayerLoader-legacy.js","./multiOriginJSONSupportUtils-legacy.js","./jsonContext-legacy.js","./saveAPIKeyUtils-legacy.js","./saveUtils-legacy.js"],(function(e,a){"use strict";var r,t,n,s,l,i,o,c,u,y,f,p,d,m,h,w,v,b,g,I,S,T,L,A;return{setters:[e=>{r=e.a,t=e.d,n=e.p,s=e.q,l=e.l,i=e.b,o=e.u,c=e.f,u=e.L,y=e.s,f=e.i},e=>{p=e.i},e=>{d=e.$,m=e.w,h=e.I,w=e.v,v=e.j,b=e.y,g=e.P,I=e.l,S=e.d,T=e.c},e=>{L=e.t},e=>{A=e.a},null,null,null,null],execute:function(){e({save:async function(e,r){return d({layer:e,itemType:a,validateLayer:O,createItemData:(e,a)=>J(a,[e]),errorNamePrefix:$},r)},saveAll:async function(e,r){await async function(e){z(e,E),await Promise.all(e.map((e=>e.load())));for(const r of e)I(r,E,O),S({layer:r,itemType:a,errorNamePrefix:E});(function(e,a){const r=e.map((e=>e.portalItem.id));if(new Set(r).size>1)throw new y(`${a}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")})(e,E),C(e,E)}(e);const t=e[0].portalItem,n=m(t),s=await Promise.all(e.map((e=>h(e,n,r)))),l=await J(t,e.map(((e,a)=>({layer:e,layerJSON:s[a]}))));return w(t),await t.update({data:l}),await Promise.all(e.slice(1).map((e=>e.portalItem.reload()))),p(n),t.clone()},saveAllAs:async function(e,r,t){await k(e);const u=b({itemType:a,errorNamePrefix:N,newItem:r}),y=m(u),f=await Promise.all(e.map((e=>h(e,y,t)))),d=await F(e.map(((e,a)=>({layer:e,layerJSON:f[a]}))));await async function(e,a){let r=0,t=0;for(const{isTable:n}of a)n?t++:r++;const u=a[0].parsedUrl.path,y=n(u);if(e.url="FeatureServer"===y?.serverType?y.url.path:u,e.title||=y.title,e.extent=null,r>0){const r=a.map((e=>e.fullExtent)).filter(s).reduce(((e,a)=>e.clone().union(a)));r&&(e.extent=await l(r))}i(e,c.METADATA),o(e,c.MULTI_LAYER,a.length>1),o(e,c.SINGLE_LAYER,1===a.length),o(e,c.TABLE,t>0&&0===r),w(e)}(u,e),await g(u,d,t);for(const a of e)a.portalItem=u.clone();return p(y),u},saveAs:async function(e,r,t){return v({layer:e,itemType:a,validateLayer:O,createItemData:(e,a)=>Promise.resolve(U(e)),errorNamePrefix:x,newItem:r,setItemProperties:G},t)}});const a="Feature Service",P="feature-layer-utils",$=`${P}-save`,x=`${P}-save-as`,E=`${P}-saveall`,N=`${P}-saveall-as`;function O(e){return{isValid:u(e)&&("feature"!==e.type||!e.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function j(e){const a=[],r=[];for(const{layer:t,layerJSON:n}of e)t.isTable?r.push(n):a.push(n);return{layers:a,tables:r}}function U(e){return j([e])}async function J(e,a){return/\/\d+\/?$/.test(e.url)?U(a[0]):F(a,e)}async function F(e,a){if(e.reverse(),!a)return j(e);const r=await async function(e,a){let r=await e.fetchData("json");if(function(e){return!!(e&&Array.isArray(e.layers)&&Array.isArray(e.tables))}(r))return r;r||={},function(e){e.layers||=[],e.tables||=[]}(r);const{layer:{url:t,customParameters:n,apiKey:s}}=a[0];return await D(r,{url:t??"",customParameters:n,apiKey:s},a.map((e=>e.layer.layerId))),r}(a,e);for(const t of e)Y(t.layer,t.layerJSON,r);return function(e,a){const r=[],t=[];for(const{layer:n}of a){const{isTable:e,layerId:a}=n;e?t.push(a):r.push(a)}M(e.layers,r),M(e.tables,t)}(r,e),r}function M(e,a){if(e.length<2)return;const t=[];for(const{id:r}of e)t.push(r);r(t.sort(R),a.slice().sort(R))&&e.sort(((e,r)=>{const t=a.indexOf(e.id),n=a.indexOf(r.id);return t<n?-1:t>n?1:0}))}function R(e,a){return e<a?-1:e>a?1:0}async function D(e,a,r){const{url:t,customParameters:n,apiKey:s}=a,{serviceJSON:l,layersJSON:i}=await L(t,{customParameters:n,apiKey:s}),o=K(e.layers,l.layers,r),c=K(e.tables,l.tables,r);e.layers=o.itemResources,e.tables=c.itemResources;const u=[...o.added,...c.added],y=i?[...i.layers,...i.tables]:[];await async function(e,a,r,t){const n=await async function(e){const a=[];e.forEach((({type:e})=>{const r=function(e){let a;switch(e){case"Feature Layer":case"Table":a="FeatureLayer";break;case"Oriented Imagery Layer":a="OrientedImageryLayer";break;case"Catalog Layer":a="CatalogLayer"}return a}(e),t=A[r];a.push(t())}));const r=await Promise.all(a),t=new Map;return e.forEach((({type:e},a)=>{t.set(e,r[a])})),t}(a),s=a.map((({id:e,type:a})=>new(n.get(a))({url:r,layerId:e,sourceJSON:t.find((({id:a})=>a===e))})));await Promise.allSettled(s.map((e=>e.load()))),s.forEach((a=>{const{layerId:r,loaded:t,defaultPopupTemplate:n}=a;if(!t||null==n)return;const s={id:r,popupInfo:n.toJSON()};"ArcGISFeatureLayer"!==a.operationalLayerType&&(s.layerType=a.operationalLayerType),Y(a,s,e)}))}(e,u,t,y)}function K(e,a,r){const n=t(e,a,((e,a)=>e.id===a.id));e=e.filter((e=>!n.removed.some((a=>a.id===e.id))));const s=n.added;return s.forEach((({id:a})=>{e.push({id:a})})),{itemResources:e,added:s.filter((({id:e})=>!r.includes(e)))}}function Y(e,a,r){e.isTable?_(r.tables,a):_(r.layers,a)}function _(e,a){const r=e.findIndex((({id:e})=>e===a.id));-1===r?e.push(a):e[r]=a}function z(e,a){if(!e.length)throw new y(`${a}:missing-parameters`,"'layers' array should contain at least one feature layer")}function C(e,a){const r=e.map((e=>e.layerId));if(new Set(r).size!==r.length)throw new y(`${a}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function G(e,a){const{url:r,layerId:t,title:s,fullExtent:o,isTable:u}=e,y=n(r);a.url="FeatureServer"===y?.serverType?r:`${r}/${t}`,a.title||=s,a.extent=null,u||null==o||(a.extent=await l(o)),i(a,c.METADATA),i(a,c.MULTI_LAYER),f(a,c.SINGLE_LAYER),u&&f(a,c.TABLE)}async function k(e){z(e,N),await Promise.all(e.map((e=>e.load())));for(const a of e)I(a,N,O);(function(e,a){for(const l of e){const r=l.parsedUrl.path,t=n(r),s=t?.url.path;if(!s)throw new y(`${a}:invalid-parameters`,T(l,`has unsupported url pattern: ${r}`),{layer:l});const i=t?.serverType;if("FeatureServer"!==i&&"MapServer"!==i)throw new y(`${a}:invalid-parameters`,T(l,`has unsupported server type: ${i}`),{layer:l});if("MapServer"===i&&e.length>1)throw new y(`${a}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const r=n(e[0].parsedUrl.path),t=r?.url.path,s=e.every((e=>{const a=n(e.parsedUrl.path);return a?.url.path===t}));if(!s)throw new y(`${a}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")})(e,N),C(e,N)}}}}));
