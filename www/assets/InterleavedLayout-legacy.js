System.register(["./BufferView-legacy.js","./types-legacy.js","./Util-legacy.js"],(function(e,t){"use strict";var s,i,r,n,h,d,u,f,l,c,o,a,p,_,y,F,g,m,w,b,v,E,A,T,M,B,U,C,L,j,x,z,V,$,k,H,I,S;return{setters:[e=>{s=e.y,i=e.u,r=e.i,n=e.c,h=e.l,d=e.p,u=e.o,f=e.m,l=e.T,c=e.h,o=e.a,a=e.b,p=e.d,_=e.A,y=e.O,F=e.x,g=e.g,m=e.w,w=e.E,b=e.L,v=e.B,E=e.F,A=e.I,T=e.U,M=e.j,B=e.V,U=e.M,C=e.S,L=e.k,j=e.q,x=e.v,z=e.z,V=e.C,$=e.D,k=e.G,H=e.H},e=>{I=e.e},e=>{S=e.s}],execute:function(){e("H",(function(){return new q}));class t{constructor(e,t){this.layout=e,this.buffer="number"==typeof t?new ArrayBuffer(t*e.stride):t;for(const s of e.fields.keys()){const t=e.fields.get(s);this[s]=new t.constructor(this.buffer,t.offset,this.stride)}}get stride(){return this.layout.stride}get count(){return this.buffer.byteLength/this.stride}get byteLength(){return this.buffer.byteLength}getField(e,t){const s=this[e];return s&&s.elementCount===t.ElementCount&&s.elementType===t.ElementType?s:null}slice(e,s){return new t(this.layout,this.buffer.slice(e*this.stride,s*this.stride))}copyFrom(e,t=0,s=0,i=e.count){const r=this.stride;if(r%4==0){const n=new Uint32Array(e.buffer,t*r,i*r/4);new Uint32Array(this.buffer,s*r,i*r/4).set(n)}else{const n=new Uint8Array(e.buffer,t*r,i*r);new Uint8Array(this.buffer,s*r,i*r).set(n)}return this}get usedMemory(){return this.byteLength}dispose(){}}class q{constructor(e=null){this._stride=0,this._lastAligned=0,this._fields=new Map,e&&(this._stride=e.stride,e.fields.forEach((e=>this._fields.set(e[0],{...e[1],constructor:O(e[1].constructor)}))))}vec2f(e,t){return this._appendField(e,i,t),this}vec2f64(e,t){return this._appendField(e,f,t),this}vec3f(e,t){return this._appendField(e,r,t),this}vec3f64(e,t){return this._appendField(e,l,t),this}vec4f(e,t){return this._appendField(e,n,t),this}vec4f64(e,t){return this._appendField(e,c,t),this}mat3f(e,t){return this._appendField(e,h,t),this}mat3f64(e,t){return this._appendField(e,o,t),this}mat4f(e,t){return this._appendField(e,d,t),this}mat4f64(e,t){return this._appendField(e,a,t),this}vec4u8(e,t){return this._appendField(e,F,t),this}f32(e,t){return this._appendField(e,s,t),this}f64(e,t){return this._appendField(e,u,t),this}u8(e,t){return this._appendField(e,p,t),this}u16(e,t){return this._appendField(e,g,t),this}i8(e,t){return this._appendField(e,M,t),this}vec2i8(e,t){return this._appendField(e,B,t),this}vec2i16(e,t){return this._appendField(e,j,t),this}vec2u8(e,t){return this._appendField(e,_,t),this}vec4u16(e,t){return this._appendField(e,b,t),this}u32(e,t){return this._appendField(e,v,t),this}_appendField(e,t,s){if(this._fields.has(e))return void S(!1,`${e} already added to vertex buffer layout`);const i=t.ElementCount*I(t.ElementType),r=this._stride;this._stride+=i,this._fields.set(e,{size:i,constructor:t,offset:r,optional:s})}createBuffer(e){return new t(this,e)}createView(e){return new t(this,e)}clone(){const e=new q;return e._stride=this._stride,e._fields=new Map,this._fields.forEach(((t,s)=>e._fields.set(s,t))),e.BufferType=this.BufferType,e}get stride(){if(this._lastAligned!==this._fields.size){let e=1;this._fields.forEach((t=>e=Math.max(e,I(t.constructor.ElementType)))),this._stride=Math.floor((this._stride+e-1)/e)*e,this._lastAligned=this._fields.size}return this._stride}get fields(){return this._fields}}e("I",class{constructor(e){this.fields=new Array,e.fields.forEach(((e,t)=>{const s={...e,constructor:G(e.constructor)};this.fields.push([t,s])})),this.stride=e.stride}});const D=[s,i,r,n,h,d,u,f,l,c,o,a,p,_,y,F,g,m,w,b,v,E,A,T,M,B,U,C,L,j,x,z,V,$,k,H];function G(e){return`${e.ElementType}_${e.ElementCount}`}function O(e){return J.get(e)}const J=new Map;D.forEach((e=>J.set(G(e),e)))}}}));
