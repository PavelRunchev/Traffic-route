System.register(["./index-legacy.js","./quat-legacy.js","./quatf64-legacy.js","./vec3f32-legacy.js","./PointCloudUniqueValueRenderer-legacy.js","./I3SBinaryReader-legacy.js","./orientedBoundingBox-legacy.js","./mat3f64-legacy.js","./VertexAttribute-legacy.js","./mat4f64-legacy.js","./computeTranslationToOriginAndRotation-legacy.js","./plane-legacy.js"],(function(t,e){"use strict";var r,o,n,l,a,s,u,i,f,c,b,d,g,p,y,m,h;return{setters:[t=>{r=t.e$,o=t.q,n=t.bc,l=t.e0,a=t.f0},t=>{s=t.O},t=>{u=t.e},t=>{i=t.t,f=t.n},t=>{c=t.a,b=t.b,d=t.d},t=>{g=t.w,p=t.l,y=t.c,m=t.I},t=>{h=t.O},null,null,null,null,null],execute:function(){function e(t,e,r){return t?.attributeInfo.useElevation?e?function(t,e){const r=new Float64Array(e);for(let o=0;o<e;o++)r[o]=t[3*o+2];return r}(e,r):null:t?.attributeInfo.storageInfo?m(t.attributeInfo.storageInfo,t.buffer,r):null}function v(t){switch(t){default:case null:case"none":return t=>t;case"low-four-bit":return t=>15&t;case"high-four-bit":return t=>(240&t)>>4;case"absolute-value":return t=>Math.abs(t);case"modulo-ten":return t=>t%10}}function I(t){let e=0;for(const r of t||[])e|=1<<r;return e}t("default",(function(){return new A}));class A{transform(t){const e=this._transform(t),o=[e.points.buffer,e.rgb.buffer];null!=e.pointIdFilterMap&&o.push(e.pointIdFilterMap.buffer);for(const n of e.attributes)"buffer"in n.values&&r(n.values.buffer)&&n.values.buffer!==e.rgb.buffer&&o.push(n.values.buffer);return Promise.resolve({result:e,transferList:o})}_transform(t){const r=function(t,e){if(null==t.encoding||""===t.encoding){const r=g(e,t);if(null==r.vertexAttributes.position)return;const o=p(e,r.vertexAttributes.position),n=r.header.fields,l=[n.offsetX,n.offsetY,n.offsetZ],a=[n.scaleX,n.scaleY,n.scaleZ],s=o.length/3,u=new Float64Array(3*s);for(let t=0;t<s;t++)u[3*t]=o[3*t]*a[0]+l[0],u[3*t+1]=o[3*t+1]*a[1]+l[1],u[3*t+2]=o[3*t+2]*a[2]+l[2];return u}if("lepcc-xyz"===t.encoding)return y(e).result}(t.schema,t.geometryBuffer);let l=r.length/3,a=null;const s=new Array,u=e(t.primaryAttributeData,r,l);null!=t.primaryAttributeData&&u&&s.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:u});const i=e(t.modulationAttributeData,r,l);null!=t.modulationAttributeData&&i&&s.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:i});let f=function(t,e,r,o){const{rendererJSON:n,isRGBRenderer:l}=t;let a=null,s=null;if(e&&l)a=e;else if(e&&"pointCloudUniqueValueRenderer"===n?.type){s=c.fromJSON(n);const t=s.colorUniqueValueInfos;a=new Uint8Array(3*o);const r=v(s.fieldTransformType);for(let n=0;n<o;n++){const o=(r?r(e[n]):e[n])+"";for(let e=0;e<t.length;e++)if(t[e].values.includes(o)){a[3*n]=t[e].color.r,a[3*n+1]=t[e].color.g,a[3*n+2]=t[e].color.b;break}}}else if(e&&"pointCloudStretchRenderer"===n?.type){s=b.fromJSON(n);const t=s.stops;a=new Uint8Array(3*o);const r=v(s.fieldTransformType);for(let n=0;n<o;n++){const o=r?r(e[n]):e[n],l=t.length-1;if(o<t[0].value)a[3*n]=t[0].color.r,a[3*n+1]=t[0].color.g,a[3*n+2]=t[0].color.b;else if(o>=t[l].value)a[3*n]=t[l].color.r,a[3*n+1]=t[l].color.g,a[3*n+2]=t[l].color.b;else for(let e=1;e<t.length;e++)if(o<t[e].value){const r=(o-t[e-1].value)/(t[e].value-t[e-1].value);a[3*n]=t[e].color.r*r+t[e-1].color.r*(1-r),a[3*n+1]=t[e].color.g*r+t[e-1].color.g*(1-r),a[3*n+2]=t[e].color.b*r+t[e-1].color.b*(1-r);break}}}else if(e&&"pointCloudClassBreaksRenderer"===n?.type){s=d.fromJSON(n);const t=s.colorClassBreakInfos;a=new Uint8Array(3*o);const r=v(s.fieldTransformType);for(let n=0;n<o;n++){const o=r?r(e[n]):e[n];for(let e=0;e<t.length;e++)if(o>=t[e].minValue&&o<=t[e].maxValue){a[3*n]=t[e].color.r,a[3*n+1]=t[e].color.g,a[3*n+2]=t[e].color.b;break}}}else a=new Uint8Array(3*o).fill(255);if(r&&s?.colorModulation){const t=s.colorModulation.minValue,e=s.colorModulation.maxValue,n=.3;for(let l=0;l<o;l++){const o=r[l],s=o>=e?1:o<=t?n:n+(1-n)*(o-t)/(e-t);a[3*l]=s*a[3*l],a[3*l+1]=s*a[3*l+1],a[3*l+2]=s*a[3*l+2]}}return a}(t.rendererInfo,u,i,l);if(t.filterInfo&&t.filterInfo.length>0&&null!=t.filterAttributesData){const n=t.filterAttributesData.filter(o).map((t=>{const o=e(t,r,l),n={attributeInfo:t.attributeInfo,values:o};return s.push(n),n}));a=new Uint32Array(l),l=function(t,e,r,o,n){const l=t.length/3;let a=0;for(let s=0;s<l;s++){let l=!0;for(let t=0;t<o.length&&l;t++){const{filterJSON:e}=o[t],r=n[t].values[s];switch(e.type){case"pointCloudValueFilter":{const t="exclude"===e.mode;e.values.includes(r)===t&&(l=!1);break}case"pointCloudBitfieldFilter":{const t=I(e.requiredSetBits),o=I(e.requiredClearBits);(r&t)===t&&!(r&o)||(l=!1);break}case"pointCloudReturnFilter":{const t=15&r,o=r>>>4&15,n=o>1,a=1===t,s=t===o;let u=!1;for(const r of e.includedReturns)if("last"===r&&s||"firstOfMany"===r&&a&&n||"lastOfMany"===r&&s&&n||"single"===r&&!n){u=!0;break}u||(l=!1);break}}}l&&(r[a]=s,t[3*a]=t[3*s],t[3*a+1]=t[3*s+1],t[3*a+2]=t[3*s+2],e[3*a]=e[3*s],e[3*a+1]=e[3*s+1],e[3*a+2]=e[3*s+2],a++)}return a}(r,f,a,t.filterInfo,n)}for(const o of t.userAttributesData){const t=e(o,r,l);s.push({attributeInfo:o.attributeInfo,values:t})}3*l<f.length&&(f=new Uint8Array(f.buffer.slice(0,3*l))),this._applyElevationOffsetInPlace(r,l,t.elevationOffset);const m=this._transformCoordinates(r,l,h.fromData(t.obbData),n.fromJSON(t.inSR),n.fromJSON(t.outSR));return{obbData:t.obbData,points:m,rgb:f,attributes:s,pointIdFilterMap:a}}_transformCoordinates(t,e,r,o,n){if(!l(t,o,0,t,n,0,e))throw new Error("Can't reproject");const u=i(r.center),c=f(),b=f(),d=i(r.halfSize);s(w,r.quaternion);const g=new Float32Array(3*e);for(let l=0;l<e;l++){let e=3*l;c[0]=t[e]-u[0],c[1]=t[e+1]-u[1],c[2]=t[e+2]-u[2],a(b,c,w),d[0]=Math.max(d[0],Math.abs(b[0])),d[1]=Math.max(d[1],Math.abs(b[1])),d[2]=Math.max(d[2],Math.abs(b[2])),g[e++]=c[0],g[e++]=c[1],g[e]=c[2]}return r.halfSize=d,g}_applyElevationOffsetInPlace(t,e,r){if(0!==r)for(let o=0;o<e;o++)t[3*o+2]+=r}}const w=u()}}}));
