System.register(["./index-legacy.js","./mat3f64-legacy.js","./mat4f64-legacy.js","./computeTranslationToOriginAndRotation-legacy.js","./DoubleArray-legacy.js","./quat-legacy.js","./quatf64-legacy.js","./meshVertexSpaceUtils-legacy.js","./vec3-legacy.js","./BufferView-legacy.js"],(function(e,t){"use strict";var n,r,o,a,i,l,c,s,u,f,p,g,y,h,m,A,x,P,d,F,T,v,M,w,b,R,_,C,j,O,S,E,N,V,L,G,W,z,I,B,U,$,q,Q,Y,X,k,D,K,Z,H,J,ee,te,ne,re,oe,ae,ie,le;return{setters:[e=>{n=e.hM,r=e.hN,o=e.g_,a=e.cR,i=e.hO,l=e.cL,c=e.gI,s=e.x,u=e.y,f=e.z,p=e.bX,g=e.ct,y=e.hP,h=e.cu,m=e.cQ,A=e.hQ,x=e.hR,P=e.d$,d=e.hS,F=e.as,T=e.w,v=e.e0,M=e.hT,w=e.eV,b=e.eU,R=e.hU,_=e.cs,C=e.hV,j=e.hW,O=e.hX,S=e.hK,E=e.hY,N=e.hZ,V=e.ev,L=e.ht,G=e.gL,W=e.h_,z=e.g$,I=e.b6,B=e.h$},e=>{U=e.e},e=>{$=e.e,q=e.o},e=>{Q=e.a,Y=e.R},e=>{X=e.t,k=e.o},e=>{D=e.v,K=e.b,Z=e.x},e=>{H=e.e},e=>{J=e.g,ee=e.f,te=e.u},e=>{ne=e.n,re=e.s,oe=e.i,ae=e.r},e=>{ie=e.i,le=e.T}],execute:function(){function t(e=ge){return[e[0],e[1],e[2],e[3]]}function ce(e,n,r=t()){return a(r,e),r[3]=n,r}function se(e,n,r=t()){return K(ye,e,fe(e)),K(he,n,fe(n)),Z(ye,he,ye),pe(r,l(D(r,ye)))}function ue(e){return e}function fe(e){return c(e[3])}function pe(e,t){return e[3]=t,e}e({A:fe,C:Xe,E:Ce,G:ke,I:De,O:$e,P:qe,Q:Ze,V:Qe,_:tt,a:_e,b:t,c:function(e,t,n,r){if(void 0!==r){F(T.getLogger(e),"option: geographic",{replacement:"use mesh vertexSpace and spatial reference to control how operations are performed",version:"4.29",warnOnce:!0});const o="local"===t.type;if(!J(t)||r===o)return n.isGeographic||n.isWebMercator&&r;T.getLogger(e).warnOnce(`Specifying the 'geographic' parameter (${r}) for a Mesh vertex space of type "${t.type}" is not supported. This parameter will be ignored.`)}return Me(t,n)},e:Re,f:Ee,h:Se,j:be,k:function(e,n=t()){const r=i(ye,e);return pe(n,l(D(n,r))),n},w:function(e,a,i,l=t()){return ce(n,e,me),ce(r,a,Ae),ce(o,i,xe),se(me,Ae,me),se(me,xe,l),l},y:ue});const ge=[0,0,1,0],ye=H(),he=H();t();const me=t(),Ae=t(),xe=t();var Pe;let de=Pe=class extends p{constructor(e){super(e),this.translation=g(),this.rotationAxis=y(ge),this.rotationAngle=0,this.scale=h(1,1,1)}get rotation(){return ce(this.rotationAxis,this.rotationAngle)}set rotation(e){this.rotationAxis=m(e),this.rotationAngle=function(e){return e[3]}(e)}get localMatrix(){const e=$();return K(Fe,this.rotation,fe(this.rotation)),A(e,Fe,this.translation,this.scale),e}get localMatrixInverse(){return x($(),this.localMatrix)}applyLocal(e,t){return P(t,e,this.localMatrix)}applyLocalInverse(e,t){return P(t,e,this.localMatrixInverse)}equals(e){return this===e||null!=e&&d(this.localMatrix,e.localMatrix)}clone(){const e={translation:m(this.translation),rotationAxis:m(this.rotationAxis),rotationAngle:this.rotationAngle,scale:m(this.scale)};return new Pe(e)}};s([u({type:[Number],nonNullable:!0,json:{write:!0}})],de.prototype,"translation",void 0),s([u({type:[Number],nonNullable:!0,json:{write:!0}})],de.prototype,"rotationAxis",void 0),s([u({type:Number,nonNullable:!0,json:{write:!0}})],de.prototype,"rotationAngle",void 0),s([u({type:[Number],nonNullable:!0,json:{write:!0}})],de.prototype,"scale",void 0),s([u()],de.prototype,"rotation",null),s([u()],de.prototype,"localMatrix",null),s([u()],de.prototype,"localMatrixInverse",null),de=Pe=s([f("esri.geometry.support.MeshTransform")],de);const Fe=H(),Te=e("d",de);function ve(e,t){return e.isGeographic||e.isWebMercator&&(t??!0)}function Me(e,t){switch(e.type){case"georeferenced":return t.isGeographic;case"local":return t.isGeographic||t.isWebMercator}}const we=()=>T.getLogger("esri.geometry.support.meshUtils.normalProjection");function be(e,t,n,r,o){return Ve(r)?(Ne(Ge.TO_PCPF,ie.fromTypedArray(e),le.fromTypedArray(t),le.fromTypedArray(n),r,ie.fromTypedArray(o)),o):(we().error("Cannot convert spatial reference to PCPF"),o)}function Re(e,t,n,r,o){return Ve(r)?(Ne(Ge.FROM_PCPF,ie.fromTypedArray(e),le.fromTypedArray(t),le.fromTypedArray(n),r,ie.fromTypedArray(o)),o):(we().error("Cannot convert to spatial reference from PCPF"),o)}function _e(e,t,n){return v(e,t,0,n,Q(t),0,e.length/3),n}function Ce(e,t,n){return v(e,Q(n),0,t,n,0,e.length/3),t}function je(e,t,n){return S(Be,n),ne(t,e,Be),E(Be)||re(t,t),t}function Oe(e,t,n){if(S(Be,n),ne(t,e,Be,4),E(Be)||re(t,t,4),e!==t)for(let r=3;r<e.length;r+=4)t[r]=e[r];return t}function Se(e,t,n,r,o){if(!Ve(r))return we().error("Cannot convert spatial reference to PCPF"),o;Ne(Ge.TO_PCPF,ie.fromTypedArray(e,4*Float32Array.BYTES_PER_ELEMENT),le.fromTypedArray(t),le.fromTypedArray(n),r,ie.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT));for(let a=3;a<e.length;a+=4)o[a]=e[a];return o}function Ee(e,t,n,r,o){if(!Ve(r))return we().error("Cannot convert to spatial reference from PCPF"),o;Ne(Ge.FROM_PCPF,ie.fromTypedArray(e,16),le.fromTypedArray(t),le.fromTypedArray(n),r,ie.fromTypedArray(o,16));for(let a=3;a<e.length;a+=4)o[a]=e[a];return o}function Ne(e,t,n,r,o,a){if(!t)return;const i=n.count,l=Q(o);if(Le(o))for(let c=0;c<i;c++)r.getVec(c,We),t.getVec(c,ze),Y(l,We,Ie,l),M(Be,Ie),e===Ge.FROM_PCPF&&w(Be,Be),b(ze,ze,Be),a.setVec(c,ze);else for(let c=0;c<i;c++){r.getVec(c,We),t.getVec(c,ze),Y(l,We,Ie,l),M(Be,Ie);const o=R(n.get(c,1));let i=Math.cos(o);e===Ge.TO_PCPF&&(i=1/i),Be[0]*=i,Be[1]*=i,Be[2]*=i,Be[3]*=i,Be[4]*=i,Be[5]*=i,e===Ge.FROM_PCPF&&w(Be,Be),b(ze,ze,Be),_(ze,ze),a.setVec(c,ze)}return a}function Ve(e){return Le(e)||function(e){return e.isWebMercator}(e)}function Le(e){return e.isWGS84||C(e)||j(e)||O(e)}var Ge;!function(e){e[e.TO_PCPF=0]="TO_PCPF",e[e.FROM_PCPF=1]="FROM_PCPF"}(Ge||(Ge={}));const We=g(),ze=g(),Ie=$(),Be=U();function Ue(e,t,n){return ve(t.spatialReference,n?.geographic)?De(e,t,!1,n):function(e,t,n){const r=new Float64Array(e.position.length),o=e.position,a=t.x,i=t.y,l=t.z??0,c=tt(n?n.unit:null,t.spatialReference);for(let s=0;s<o.length;s+=3)r[s]=o[s]*c+a,r[s+1]=o[s+1]*c+i,r[s+2]=o[s+2]*c+l;return{position:r,normal:e.normal,tangent:e.tangent}}(e,t,n)}function $e(e,t=o){const{position:n,normal:r,tangent:o}=e;return{position:ae(new Float64Array(n.length),n,t),normal:null!=r?je(r,new Float32Array(r.length),t):null,tangent:null!=o?Oe(o,new Float32Array(o.length),t):null}}function qe(e,t,n,r){const{position:o,normal:a,tangent:i}=e;if(!J(t))return{position:o,normal:a,tangent:i};const l=te(t,r);return Ue($e(e,n?.localMatrix),l,{geographic:"local"===t.type})}function Qe(e,t,n){const r=ee(t,n),o=t.spatialReference,a=J(r);if(!a)return{vertexAttributes:Ue(e,t,n),vertexSpace:r,transform:null};const{position:i,normal:l,tangent:c}=e,s=Me(r,o);switch(r.type){case"georeferenced":return s?{vertexAttributes:De(e,t,a,n),vertexSpace:r,transform:null}:{vertexAttributes:{position:i,normal:l,tangent:c},vertexSpace:r,transform:new Te};case"local":return{vertexAttributes:{position:i,normal:l,tangent:c},vertexSpace:r,transform:new Te}}}function Ye(e,t,n){return ve(t.spatialReference,n?.geographic)?Ze(e,t,n):Ke(e,t,n)}function Xe(e,t,n,r,o){if(!J(t))return Ye(e,r,o);const{spatialReference:a}=r,i=qe(e,t,n,a);return r.equals(te(t,a))?Ke(i,r,o):Ye(i,r,o)}function ke({positions:e,transform:t,vertexSpace:n,inSpatialReference:r,outSpatialReference:o,outPositions:a,localMode:i}){const l=n.origin??G,c=null!=n.origin?t?.localMatrix??q:q;if("georeferenced"===n.type){const t=a??X(e.length);if(W(c,q)?k(t,e):ae(t,e,c),!z(l,G)){const[e,n,r]=l;for(let o=0;o<t.length;o+=3)t[o]+=e,t[o+1]+=n,t[o+2]+=r}return v(t,r,0,t,o,0,t.length/3),t}let s=r;const u=Q(r);s=o.isWebMercator&&i||!I(r,u)?s:u,Y(r,l,nt,s),B(nt,nt,c);const f=a??X(e.length);return ae(f,e,nt),v(f,s,0,f,o,0,f.length/3),f}function De(e,t,n,r){const o=t.spatialReference,a=He(t,r,nt),i=new Float64Array(e.position.length),l=function(e,t,n,r){ae(r,e,t);const o=new Float64Array(e.length);return Ce(r,o,n)}(e.position,a,o,i),c=S(ot,a),s=function(e,t,n,r,o){if(null==n)return null;const a=new Float32Array(n.length);return ne(a,n,r),Re(a,e,t,o,a),a}(l,i,e.normal,c,o),u=function(e,t,n,r,o){if(null==n)return null;const a=new Float32Array(n.length);ne(a,n,r,4);for(let i=3;i<a.length;i+=4)a[i]=n[i];return Ee(a,e,t,o,a),a}(l,i,e.tangent,c,o);if(n){const{x:e,y:n,z:r}=t;oe(l,l,[-e,-n,-(r??0)])}return{position:l,normal:s,tangent:u}}function Ke(e,t,n){const r=new Float64Array(e.position.length),o=e.position,a=t.x,i=t.y,l=t.z??0,c=tt(n?n.unit:null,t.spatialReference);for(let s=0;s<o.length;s+=3)r[s]=(o[s]-a)/c,r[s+1]=(o[s+1]-i)/c,r[s+2]=(o[s+2]-l)/c;return{position:r,normal:e.normal,tangent:e.tangent}}function Ze(e,t,n){const r=t.spatialReference;He(t,n,nt);const o=x(rt,nt),a=new Float64Array(e.position.length),i=function(e,t,n,r){const o=_e(e,t,r),a=new Float64Array(o.length);return ae(a,o,n),a}(e.position,r,o,a),l=S(ot,o);return{position:i,normal:Je(e.normal,e.position,a,r,l),tangent:et(e.tangent,e.position,a,r,l)}}function He(e,t,n){Y(e.spatialReference,[e.x,e.y,e.z??0],n,Q(e.spatialReference));const r=tt(t?t.unit:null,e.spatialReference);return N(n,n,[r,r,r]),n}function Je(e,t,n,r,o){if(null==e)return null;const a=be(e,t,n,r,new Float32Array(e.length));return ne(a,a,o),a}function et(e,t,n,r,o){if(null==e)return null;const a=Se(e,t,n,r,new Float32Array(e.length));return ne(a,a,o,4),a}function tt(e,t){if(null==e)return 1;const n=V(t);return 1/L(n,"meters",e)}const nt=$(),rt=$(),ot=U(),at=Object.freeze(Object.defineProperty({__proto__:null,applyTransform:$e,georeference:Ue,georeferenceApplyTransform:qe,georeferenceByTransform:Qe,georeferenceGlobal:De,getUnitScale:tt,project:ke,ungeoreference:Ye,ungeoreferenceByTransform:Xe,ungeoreferenceGlobal:Ze},Symbol.toStringTag,{value:"Module"}));e("g",at)}}}));
