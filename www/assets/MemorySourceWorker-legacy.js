System.register(["./index-legacy.js","./featureConversionUtils-legacy.js","./objectIdUtils-legacy.js","./FeatureStore-legacy.js","./timeSupport-legacy.js","./QueryEngine-legacy.js","./clientSideDefaults-legacy.js","./sourceUtils-legacy.js","./OptimizedGeometry-legacy.js","./OptimizedFeatureSet-legacy.js","./BoundsStore-legacy.js","./PooledRBush-legacy.js","./json-legacy.js","./WhereClause-legacy.js","./TimeOnly-legacy.js","./QueryEngineCapabilities-legacy.js","./utils-legacy4.js","./utils-legacy3.js","./utils-legacy5.js","./ClassBreaksDefinition-legacy.js","./RenderState-legacy.js","./date-legacy.js"],(function(e,t){"use strict";var i,s,n,a,r,l,u,d,o,c,y,p,f,g,m,h,I,j,F,b,E,T,_,x,R,q;return{setters:[e=>{i=e.cx,s=e.s,n=e.cy,a=e.cA,r=e.cz,l=e.aZ,u=e.cC,d=e.cw,o=e.a0},e=>{c=e.e,y=e.n,p=e.t},e=>{f=e.t,g=e.n},e=>{m=e.m},e=>{h=e.x,I=e.j},e=>{j=e.$},e=>{F=e.i,b=e.o,E=e.a},e=>{T=e.j,_=e.f,x=e.p,R=e.d,q=e.y},null,null,null,null,null,null,null,null,null,null,null,null,null,null],execute:function(){const t=d,O={xmin:-180,ymin:-90,xmax:180,ymax:90,spatialReference:d},S={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};function D(e){return o(e)?null!=e.z:!!e.hasZ}function w(e){return o(e)?null!=e.m:!!e.hasM}e("default",class{constructor(){this._queryEngine=null,this._nextObjectId=null}destroy(){this._queryEngine?.destroy(),this._queryEngine=this._createDefaultAttributes=null}async load(e){const u=[],{features:d}=e,o=this._inferLayerProperties(d,e.fields),c=e.fields||[],y=null!=e.hasM?e.hasM:!!o.hasM,p=null!=e.hasZ?e.hasZ:!!o.hasZ,I=!e.spatialReference&&!o.spatialReference,T=I?t:e.spatialReference||o.spatialReference,_=I?O:null,x=e.geometryType||o.geometryType,R=!x;let q=e.objectIdField||o.objectIdField,D=e.timeInfo;const w=new i(c);if(!R&&(I&&u.push({name:"feature-layer:spatial-reference-not-found",message:"Spatial reference not provided or found in features. Defaults to WGS84"}),!x))throw new s("feature-layer:missing-property","geometryType not set and couldn't be inferred from the provided features");if(!q)throw new s("feature-layer:missing-property","objectIdField not set and couldn't be found in the provided fields");if(o.objectIdField&&q!==o.objectIdField&&(u.push({name:"feature-layer:duplicated-oid-field",message:`Provided objectIdField "${q}" doesn't match the field name "${o.objectIdField}", found in the provided fields`}),q=o.objectIdField),q&&!o.objectIdField){const e=w.get(q);e?(q=e.name,e.type="esriFieldTypeOID",e.editable=!1,e.nullable=!1):c.unshift({alias:q,name:q,type:"esriFieldTypeOID",editable:!1,nullable:!1})}for(const t of c){if(null==t.name&&(t.name=t.alias),null==t.alias&&(t.alias=t.name),!t.name)throw new s("feature-layer:invalid-field-name","field name is missing",{field:t});if(t.name===q&&(t.type="esriFieldTypeOID"),!n.jsonValues.includes(t.type))throw new s("feature-layer:invalid-field-type",`invalid type for field "${t.name}"`,{field:t});null==t.length&&(t.length=a(t))}const v={};for(const t of c)if("esriFieldTypeOID"!==t.type&&"esriFieldTypeGlobalID"!==t.type){const e=r(t);void 0!==e&&(v[t.name]=e)}if(D){if(D.startTimeField){const e=w.get(D.startTimeField);e?(D.startTimeField=e.name,e.type="esriFieldTypeDate"):D.startTimeField=null}if(D.endTimeField){const e=w.get(D.endTimeField);e?(D.endTimeField=e.name,e.type="esriFieldTypeDate"):D.endTimeField=null}if(D.trackIdField){const e=w.get(D.trackIdField);e?D.trackIdField=e.name:(D.trackIdField=null,u.push({name:"feature-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:D}}))}D.startTimeField||D.endTimeField||(u.push({name:"feature-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing or invalid",details:{timeInfo:D}}),D=null)}const Q=w.dateFields.length?{timeZoneIANA:e.dateFieldsTimeZone??l}:null;this._createDefaultAttributes=F(v,q);const M={warnings:u,featureErrors:[],layerDefinition:{...S,drawingInfo:b(x),templates:E(v),extent:_,geometryType:x,objectIdField:q,fields:c,hasZ:p,hasM:y,timeInfo:D,dateFieldsTimeReference:Q},assignedObjectIds:{}};if(this._queryEngine=new j({fieldsIndex:i.fromLayerJSON({fields:c,timeInfo:D,dateFieldsTimeReference:Q}),geometryType:x,hasM:y,hasZ:p,objectIdField:q,spatialReference:T,featureStore:new m({geometryType:x,hasM:y,hasZ:p}),timeInfo:D,cacheSpatialQueries:!0}),!d?.length)return this._nextObjectId=f,M;const Z=g(q,d);return this._nextObjectId=Z+1,await h(d,T),this._loadInitialFeatures(M,d)}async applyEdits(e){const{spatialReference:t,geometryType:i}=this._queryEngine;return await Promise.all([T(t,i),h(e.adds,t),h(e.updates,t)]),this._applyEdits(e)}queryFeatures(e,t={}){return this._queryEngine.executeQuery(e,t.signal)}queryFeatureCount(e,t={}){return this._queryEngine.executeQueryForCount(e,t.signal)}queryObjectIds(e,t={}){return this._queryEngine.executeQueryForIds(e,t.signal)}queryExtent(e,t={}){return this._queryEngine.executeQueryForExtent(e,t.signal)}querySnapping(e,t={}){return this._queryEngine.executeQueryForSnapping(e,t.signal)}_inferLayerProperties(e,t){let i,s,n=null,a=null,r=null;for(const l of e){const e=l.geometry;if(null!=e&&(n||(n=u(e)),a||(a=e.spatialReference),null==i&&(i=D(e)),null==s&&(s=w(e)),n&&a&&null!=i&&null!=s))break}if(t&&t.length){let e=null;t.some((t=>{const i="esriFieldTypeOID"===t.type,s=!t.type&&t.name&&"objectid"===t.name.toLowerCase();return e=t,i||s}))&&(r=e.name)}return{geometryType:n,spatialReference:a,objectIdField:r,hasM:s,hasZ:i}}async _loadInitialFeatures(e,t){const{geometryType:i,hasM:s,hasZ:n,objectIdField:a,spatialReference:r,featureStore:l,fieldsIndex:d}=this._queryEngine,o=[];for(const c of t){if(null!=c.uid&&(e.assignedObjectIds[c.uid]=-1),c.geometry&&i!==u(c.geometry)){e.featureErrors.push(_("Incorrect geometry type."));continue}const t=this._createDefaultAttributes(),s=x(d,t,c.attributes,!0);s?e.featureErrors.push(s):(this._assignObjectId(t,c.attributes,!0),c.attributes=t,null!=c.uid&&(e.assignedObjectIds[c.uid]=c.attributes[a]),null!=c.geometry&&(c.geometry=I(c.geometry,c.geometry.spatialReference,r)),o.push(c))}l.addMany(c([],o,i,n,s,a));const{fullExtent:y,timeExtent:p}=await this._queryEngine.fetchRecomputedExtents();if(e.layerDefinition.extent=y,p){const{start:t,end:i}=p;e.layerDefinition.timeInfo.timeExtent=[t,i]}return e}async _applyEdits(e){const{adds:t,updates:i,deletes:s}=e,n={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(t?.length&&this._applyAddEdits(n,t),i?.length&&this._applyUpdateEdits(n,i),s?.length){for(const e of s)n.deleteResults.push(R(e));this._queryEngine.featureStore.removeManyById(s)}const{fullExtent:a,timeExtent:r}=await this._queryEngine.fetchRecomputedExtents();return{extent:a,timeExtent:r,featureEditResults:n}}_applyAddEdits(e,t){const{addResults:i}=e,{geometryType:s,hasM:n,hasZ:a,objectIdField:r,spatialReference:l,featureStore:d,fieldsIndex:o}=this._queryEngine,y=[];for(const c of t){if(c.geometry&&s!==u(c.geometry)){i.push(_("Incorrect geometry type."));continue}const t=this._createDefaultAttributes(),n=x(o,t,c.attributes);if(n)i.push(n);else{if(this._assignObjectId(t,c.attributes),c.attributes=t,null!=c.uid){const t=c.attributes[r];e.uidToObjectId[c.uid]=t}if(null!=c.geometry){const e=c.geometry.spatialReference??l;c.geometry=I(q(c.geometry,e),e,l)}y.push(c),i.push(R(c.attributes[r]))}}d.addMany(c([],y,s,a,n,r))}_applyUpdateEdits({updateResults:e},t){const{geometryType:i,hasM:s,hasZ:n,objectIdField:a,spatialReference:r,featureStore:l,fieldsIndex:d}=this._queryEngine;for(const o of t){const{attributes:t,geometry:c}=o,f=t?.[a];if(null==f){e.push(_(`Identifier field ${a} missing`));continue}if(!l.has(f)){e.push(_(`Feature with object id ${f} missing`));continue}const g=y(l.getFeature(f),i,n,s);if(null!=c){if(i!==u(c)){e.push(_("Incorrect geometry type."));continue}const t=c.spatialReference??r;g.geometry=I(q(c,t),t,r)}if(t){const i=x(d,g.attributes,t);if(i){e.push(i);continue}}l.add(p(g,i,n,s,a)),e.push(R(f))}}_assignObjectId(e,t,i=!1){const s=this._queryEngine.objectIdField;i&&t&&isFinite(t[s])?e[s]=t[s]:e[s]=this._nextObjectId++}})}}}));
