System.register(["./index-legacy.js","./featureConversionUtils-legacy.js","./FeatureStore-legacy.js","./timeSupport-legacy.js","./QueryEngine-legacy.js","./geojson-legacy.js","./clientSideDefaults-legacy.js","./sourceUtils-legacy.js","./OptimizedGeometry-legacy.js","./OptimizedFeatureSet-legacy.js","./BoundsStore-legacy.js","./PooledRBush-legacy.js","./json-legacy.js","./WhereClause-legacy.js","./TimeOnly-legacy.js","./QueryEngineCapabilities-legacy.js","./utils-legacy4.js","./utils-legacy3.js","./utils-legacy5.js","./ClassBreaksDefinition-legacy.js","./RenderState-legacy.js","./date-legacy.js"],(function(e,t){"use strict";var s,i,n,a,r,o,l,u,d,c,y,p,h,g,m,f,_,j,F,I,E,b,T,w,q,x,S,R,O,C,k,D,Q;return{setters:[e=>{s=e.cw,i=e.cx,n=e.s,a=e.cy,r=e.cz,o=e.cA,l=e.aZ,u=e.cB,d=e.o,c=e.w,y=e.G,p=e.X,h=e.cC},e=>{g=e.o,m=e.r,f=e.e,_=e.n,j=e.t},e=>{F=e.m},e=>{I=e.x,E=e.j},e=>{b=e.$},e=>{T=e.I,w=e.N,q=e.E},e=>{x=e.o,S=e.a,R=e.i},e=>{O=e.j,C=e.p,k=e.d,D=e.f,Q=e.y},null,null,null,null,null,null,null,null,null,null,null,null,null,null],execute:function(){const t={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};e("default",class{constructor(){this._queryEngine=null,this._snapshotFeatures=async e=>{const t=await this._fetch(e);return this._createFeatures(t)}}destroy(){this._queryEngine?.destroy(),this._queryEngine=this._createDefaultAttributes=null}async load(e,u={}){this._loadOptions={url:e.url,customParameters:e.customParameters};const d=[],[c]=await Promise.all([e.url?this._fetch(u?.signal):null,this._checkProjection(e.spatialReference)]),y=T(c,{geometryType:e.geometryType}),p=e.fields||y.fields||[],h=null!=e.hasZ?e.hasZ:y.hasZ,g=y.geometryType;let m=e.objectIdField||y.objectIdFieldName||"__OBJECTID";const f=e.spatialReference||s;let _=e.timeInfo;p===y.fields&&y.unknownFields.length>0&&d.push({name:"geojson-layer:unknown-field-types",message:"Some fields types couldn't be inferred from the features and were dropped",details:{unknownFields:y.unknownFields}});const j=new i(p);let I=j.get(m);I?("esriFieldTypeString"!==I.type&&(I.type="esriFieldTypeOID"),I.editable=!1,I.nullable=!1,m=I.name):(I={alias:m,name:m,type:"string"===y.objectIdFieldType?"esriFieldTypeString":"esriFieldTypeOID",editable:!1,nullable:!1},p.unshift(I));const E={};for(const t of p){if(null==t.name&&(t.name=t.alias),null==t.alias&&(t.alias=t.name),!t.name)throw new n("geojson-layer:invalid-field-name","field name is missing",{field:t});if(!a.jsonValues.includes(t.type))throw new n("geojson-layer:invalid-field-type",`invalid type for field "${t.name}"`,{field:t});if(t.name!==I.name){const e=r(t);void 0!==e&&(E[t.name]=e)}null==t.length&&(t.length=o(t))}if(_){if(_.startTimeField){const e=j.get(_.startTimeField);e?(_.startTimeField=e.name,e.type="esriFieldTypeDate"):_.startTimeField=null}if(_.endTimeField){const e=j.get(_.endTimeField);e?(_.endTimeField=e.name,e.type="esriFieldTypeDate"):_.endTimeField=null}if(_.trackIdField){const e=j.get(_.trackIdField);e?_.trackIdField=e.name:(_.trackIdField=null,d.push({name:"geojson-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:_}}))}_.startTimeField||_.endTimeField||(d.push({name:"geojson-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing",details:{timeInfo:_}}),_=null)}const w=g?x(g):void 0,q=j.dateFields.length?{timeZoneIANA:l}:null,O={warnings:d,featureErrors:[],layerDefinition:{...t,drawingInfo:w??void 0,templates:S(E),extent:void 0,geometryType:g,objectIdField:m,fields:p,hasZ:!!h,timeInfo:_,dateFieldsTimeReference:q}};this._queryEngine=new b({fieldsIndex:i.fromLayerJSON({fields:p,timeInfo:_,dateFieldsTimeReference:q}),geometryType:g,hasM:!1,hasZ:h,objectIdField:m,spatialReference:f,timeInfo:_,featureStore:new F({geometryType:g,hasM:!1,hasZ:h}),cacheSpatialQueries:!0});const C=this._queryEngine.fieldsIndex.requiredFields.indexOf(I);C>-1&&this._queryEngine.fieldsIndex.requiredFields.splice(C,1),this._createDefaultAttributes=R(E,m);const k=await this._createFeatures(c);this._objectIdGenerator=this._createObjectIdGenerator(this._queryEngine,k);const D=this._normalizeFeatures(k,O.featureErrors);this._queryEngine.featureStore.addMany(D);const{fullExtent:Q,timeExtent:v}=await this._queryEngine.fetchRecomputedExtents();if(O.layerDefinition.extent=Q,v){const{start:e,end:t}=v;O.layerDefinition.timeInfo.timeExtent=[e,t]}return O}async applyEdits(e){const{spatialReference:t,geometryType:s}=this._queryEngine;return await Promise.all([O(t,s),I(e.adds,t),I(e.updates,t)]),await this._waitSnapshotComplete(),this._applyEdits(e)}async queryFeatures(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQuery(e,t.signal)}async queryFeatureCount(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForCount(e,t.signal)}async queryObjectIds(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForIds(e,t.signal)}async queryExtent(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForExtent(e,t.signal)}async querySnapping(e,t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForSnapping(e,t.signal)}async refresh(e){this._loadOptions.customParameters=e,this._snapshotTask?.abort(),this._snapshotTask=u(this._snapshotFeatures),this._snapshotTask.promise.then((e=>{this._queryEngine.featureStore.clear(),this._objectIdGenerator=this._createObjectIdGenerator(this._queryEngine,e);const t=this._normalizeFeatures(e);t&&this._queryEngine.featureStore.addMany(t)}),(e=>{this._queryEngine.featureStore.clear(),d(e)||c.getLogger("esri.layers.GeoJSONLayer").error(new n("geojson-layer:refresh","An error occurred during refresh",{error:e}))})),await this._waitSnapshotComplete();const{fullExtent:t,timeExtent:s}=await this._queryEngine.fetchRecomputedExtents();return{extent:t,timeExtent:s}}async _createFeatures(e){if(null==e)return[];const{geometryType:t,hasZ:i,objectIdField:n}=this._queryEngine,a=w(e,{geometryType:t,hasZ:i,objectIdField:n});if(!y(this._queryEngine.spatialReference,s))for(const r of a)null!=r.geometry&&(r.geometry=g(E(m(r.geometry,this._queryEngine.geometryType,this._queryEngine.hasZ,!1),s,this._queryEngine.spatialReference)));return a}async _waitSnapshotComplete(){if(this._snapshotTask&&!this._snapshotTask.finished){try{await this._snapshotTask.promise}catch{}return this._waitSnapshotComplete()}}async _fetch(e){const{url:t,customParameters:s}=this._loadOptions,i=(await p(t,{responseType:"json",query:{...s},signal:e})).data;return q(i),i}_normalizeFeatures(e,t){const{objectIdField:s,fieldsIndex:i}=this._queryEngine,n=[];for(const a of e){const e=this._createDefaultAttributes(),r=C(i,e,a.attributes,!0);r?t?.push(r):(this._assignObjectId(e,a.attributes,!0),a.attributes=e,a.objectId=e[s],n.push(a))}return n}async _applyEdits(e){const{adds:t,updates:s,deletes:i}=e,n={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(t?.length&&this._applyAddEdits(n,t),s?.length&&this._applyUpdateEdits(n,s),i?.length){for(const e of i)n.deleteResults.push(k(e));this._queryEngine.featureStore.removeManyById(i)}const{fullExtent:a,timeExtent:r}=await this._queryEngine.fetchRecomputedExtents();return{extent:a,timeExtent:r,featureEditResults:n}}_applyAddEdits(e,t){const{addResults:s}=e,{geometryType:i,hasM:n,hasZ:a,objectIdField:r,spatialReference:o,featureStore:l,fieldsIndex:u}=this._queryEngine,d=[];for(const c of t){if(c.geometry&&i!==h(c.geometry)){s.push(D("Incorrect geometry type."));continue}const t=this._createDefaultAttributes(),n=C(u,t,c.attributes);if(n)s.push(n);else{if(this._assignObjectId(t,c.attributes),c.attributes=t,null!=c.uid){const t=c.attributes[r];e.uidToObjectId[c.uid]=t}if(null!=c.geometry){const e=c.geometry.spatialReference??o;c.geometry=E(Q(c.geometry,e),e,o)}d.push(c),s.push(k(c.attributes[r]))}}l.addMany(f([],d,i,a,n,r))}_applyUpdateEdits({updateResults:e},t){const{geometryType:s,hasM:i,hasZ:n,objectIdField:a,spatialReference:r,featureStore:o,fieldsIndex:l}=this._queryEngine;for(const u of t){const{attributes:t,geometry:d}=u,c=t?.[a];if(null==c){e.push(D(`Identifier field ${a} missing`));continue}if(!o.has(c)){e.push(D(`Feature with object id ${c} missing`));continue}const y=_(o.getFeature(c),s,n,i);if(null!=d){if(s!==h(d)){e.push(D("Incorrect geometry type."));continue}const t=d.spatialReference??r;y.geometry=E(Q(d,t),t,r)}if(t){const s=C(l,y.attributes,t);if(s){e.push(s);continue}}o.add(j(y,s,n,i,a)),e.push(k(c))}}_createObjectIdGenerator(e,t){const s=e.fieldsIndex.get(e.objectIdField);if("esriFieldTypeString"===s.type)return()=>s.name+"-"+Date.now().toString(16);let i=Number.NEGATIVE_INFINITY;for(const n of t)n.objectId&&(i=Math.max(i,n.objectId));return i=Math.max(0,i)+1,()=>i++}_assignObjectId(e,t,s=!1){const i=this._queryEngine.objectIdField;e[i]=s&&i in t?t[i]:this._objectIdGenerator()}async _checkProjection(e){try{await I(s,e)}catch{throw new n("geojson-layer","Projection not supported")}}})}}}));
