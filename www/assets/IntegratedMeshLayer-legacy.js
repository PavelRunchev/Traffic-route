System.register(["./index-legacy.js","./persistable-legacy.js","./SceneService-legacy.js","./I3SLayerDefinitions-legacy.js","./elevationInfoUtils-legacy.js","./multiOriginJSONSupportUtils-legacy.js","./resourceExtension-legacy.js","./originUtils-legacy.js","./jsonContext-legacy.js","./resourceUtils-legacy3.js","./resourceUtils-legacy2.js","./saveAPIKeyUtils-legacy.js","./saveUtils-legacy.js"],(function(e,t){"use strict";var i,s,o,r,n,a,l,p,y,c,d,u,h,f,m,g,v,S,w,x,j,I,O,T,_,b,L,N,R,U,M,A,J,D,E,P,V,K,z,G;return{setters:[e=>{i=e.x,s=e.y,o=e.aN,r=e.dN,n=e.z,a=e.bX,l=e.b6,p=e.cX,y=e.he,c=e.ax,d=e.da,u=e.V,h=e.ao,f=e.X,m=e.dE,g=e.de,v=e.df,S=e.bt,w=e.dg,x=e.dG,j=e.dF,I=e.R,O=e.en,T=e.bL,_=e.bx,b=e.s,L=e.w,N=e.bD,R=e.e5,U=e.bw},e=>{M=e.j},e=>{A=e.L,J=e.P},e=>{D=e.s,E=e.l,P=e.u,V=e.m},e=>{K=e.I,z=e.x,G=e.Z},null,null,null,null,null,null,null,null],execute:function(){var t;let X=t=class extends a{constructor(e){super(e),this.geometry=null,this.type="clip"}writeGeometry(e,t,i,s){if(s.layer?.spatialReference&&!s.layer.spatialReference.equals(this.geometry.spatialReference)){if(!l(e.spatialReference,s.layer.spatialReference))return void(s?.messages&&s.messages.push(new p("scenemodification:unsupported","Scene modifications with incompatible spatial references are not supported",{modification:this,spatialReference:s.layer.spatialReference,context:s})));const r=new o;y(e,r,s.layer.spatialReference),t[i]=r.toJSON(s)}else t[i]=e.toJSON(s);delete t[i].spatialReference}clone(){return new t({geometry:c(this.geometry),type:this.type})}};i([s({type:o}),M()],X.prototype,"geometry",void 0),i([r(["web-scene","portal-item"],"geometry")],X.prototype,"writeGeometry",null),i([s({type:["clip","mask","replace"],nonNullable:!0}),M()],X.prototype,"type",void 0),X=t=i([n("esri.layers.support.SceneModification")],X);const C=X;var F;let k=F=class extends(d(u.ofType(C))){constructor(e){super(e),this.url=null}clone(){return new F({url:this.url,items:this.items.map((e=>e.clone()))})}toJSON(e){return this.toArray().map((t=>t.toJSON(e))).filter((e=>!!e.geometry))}static fromJSON(e,t){const i=new F;for(const s of e)i.add(C.fromJSON(s,t));return i}static async fromUrl(e,t,i){const s={url:h(e),origin:"service"},o=await f(e,{responseType:"json",signal:i?.signal}),r=t.toJSON(),n=[];for(const a of o.data)n.push(C.fromJSON({...a,geometry:{...a.geometry,spatialReference:r}},s));return new F({url:e,items:n})}};i([s({type:String})],k.prototype,"url",void 0),k=F=i([n("esri.layers.support.SceneModifications")],k);const q=k;let H=class extends(A(m(g(v(S(w(x(j(U))))))))){constructor(...e){super(...e),this.geometryType="mesh",this.operationalLayerType="IntegratedMeshLayer",this.type="integrated-mesh",this.nodePages=null,this.materialDefinitions=null,this.textureSetDefinitions=null,this.geometryDefinitions=null,this.serviceUpdateTimeStamp=null,this.profile="mesh-pyramids",this.modifications=null,this._modificationsSource=null,this.path=null}initialize(){this.addHandles(I((()=>this.modifications),"after-changes",(()=>this.modifications=this.modifications),O))}normalizeCtorArgs(e,t){return"string"==typeof e?{url:e,...t}:e}readModifications(e,t,i){this._modificationsSource={url:T(e,i),context:i}}set elevationInfo(e){this._set("elevationInfo",e),this._validateElevationInfo()}async load(e){return this.addResolvingPromise(this._doLoad(e)),this}async _doLoad(e){const t=e?.signal;try{await this.loadFromPortal({supportedTypes:["Scene Service"]},e)}catch(N){_(N)}if(await this._fetchService(t),null!=this._modificationsSource){const t=await q.fromUrl(this._modificationsSource.url,this.spatialReference,e);this.setAtOrigin("modifications",t,this._modificationsSource.context.origin),this._modificationsSource=null}await this._fetchIndexAndUpdateExtent(this.nodePages,t)}beforeSave(){if(null!=this._modificationsSource)return this.load().then((()=>{}),(()=>{}))}async saveAs(e,t){return this._debouncedSaveOperations(J.SAVE_AS,{...t,getTypeKeywords:()=>this._getTypeKeywords(),portalItemLayerType:"integrated-mesh"},e)}async save(){const e={getTypeKeywords:()=>this._getTypeKeywords(),portalItemLayerType:"integrated-mesh"};return this._debouncedSaveOperations(J.SAVE,e)}validateLayer(e){if(e.layerType&&"IntegratedMesh"!==e.layerType)throw new b("integrated-mesh-layer:layer-type-not-supported","IntegratedMeshLayer does not support this layer type",{layerType:e.layerType});if(isNaN(this.version.major)||isNaN(this.version.minor))throw new b("layer:service-version-not-supported","Service version is not supported.",{serviceVersion:this.version.versionString,supportedVersions:"1.x"});if(this.version.major>1)throw new b("layer:service-version-too-new","Service version is too new.",{serviceVersion:this.version.versionString,supportedVersions:"1.x"})}_getTypeKeywords(){return["IntegratedMeshLayer"]}_validateElevationInfo(){const e=this.elevationInfo,t="Integrated mesh layers";K(L.getLogger(this),z(t,"absolute-height",e)),K(L.getLogger(this),G(t,e))}};i([s({type:String,readOnly:!0})],H.prototype,"geometryType",void 0),i([s({type:["show","hide"]})],H.prototype,"listMode",void 0),i([s({type:["IntegratedMeshLayer"]})],H.prototype,"operationalLayerType",void 0),i([s({json:{read:!1},readOnly:!0})],H.prototype,"type",void 0),i([s({type:D,readOnly:!0})],H.prototype,"nodePages",void 0),i([s({type:[E],readOnly:!0})],H.prototype,"materialDefinitions",void 0),i([s({type:[P],readOnly:!0})],H.prototype,"textureSetDefinitions",void 0),i([s({type:[V],readOnly:!0})],H.prototype,"geometryDefinitions",void 0),i([s({readOnly:!0})],H.prototype,"serviceUpdateTimeStamp",void 0),i([s({type:q}),M({origins:["web-scene","portal-item"],type:"resource",prefix:"modifications"})],H.prototype,"modifications",void 0),i([N(["web-scene","portal-item"],"modifications")],H.prototype,"readModifications",null),i([s(R)],H.prototype,"elevationInfo",null),i([s({type:String,json:{origins:{"web-scene":{read:!0,write:!0},"portal-item":{read:!0,write:!0}},read:!1}})],H.prototype,"path",void 0),H=i([n("esri.layers.IntegratedMeshLayer")],H),e("default",H)}}}));
