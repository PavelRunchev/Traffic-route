System.register(["./index-legacy.js","./Mesh-legacy.js","./georeference-legacy.js","./External-legacy.js","./infoFor3D-legacy.js","./imageUtils-legacy2.js","./MeshLocalVertexSpace-legacy.js","./meshVertexSpaceUtils-legacy.js","./vec3-legacy.js","./earcut-legacy.js","./DoubleArray-legacy.js","./Indices-legacy.js","./deduplicate-legacy.js","./plane-legacy.js","./mat3f64-legacy.js","./mat4f64-legacy.js","./quatf64-legacy.js","./triangle-legacy.js","./Util-legacy.js","./ObjectStack-legacy.js","./lineSegment-legacy.js","./basicInterfaces-legacy.js","./VertexAttribute-legacy.js","./quat-legacy.js","./computeTranslationToOriginAndRotation-legacy.js","./BufferView-legacy.js"],(function(e,t){"use strict";var n,r,s,a,l,o,u,c,i,f,g,y;return{setters:[e=>{n=e.E,r=e.bc,s=e.M,a=e.aQ,l=e.ar,o=e.e7,u=e.w},e=>{c=e.$},e=>{i=e.d},e=>{f=e.o,g=e.i},e=>{y=e.s},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],execute:function(){e({assetMapFromAssetMapsJSON:j,extractMesh:m,meshFeatureSetFromJSON:function(e,t,a){const l=a.features;a.features=[],delete a.geometryType;const o=n.fromJSON(a);if(o.geometryType="mesh",!a.assetMaps)return o;const u=j(t,a.assetMaps),c=e.sourceSpatialReference??r.WGS84,i=a.globalIdFieldName,{outFields:f}=e,g=null!=f&&f.length>0?(y=f.includes("*")?null:new Set(f),({attributes:e})=>{if(!e)return{};if(!y)return e;for(const t in e)y.has(t)||delete e[t];return e}):()=>({});var y;for(const n of l){const e=m(n,i,c,t,u);null!=e&&o.features.push(new s({geometry:e,attributes:g(n)}))}return o}});const t=()=>u.getLogger("esri.rest.support.meshFeatureSet");function m(e,n,r,s,o){const u=e.attributes[n],f=o.get(u);if(null==f)return t().error("mesh-feature-set:asset-not-found","Service returned a feature which was not found in the asset map",e),null;if(!e.geometry)return t().error("mesh-feature-set:no-geometry","Service returned a feature without geometry",e),null;const g=function({attributes:e},t,{transformFieldRoles:n}){const r=e[n.originX],s=e[n.originY],a=e[n.originZ];return new l({x:r,y:s,z:a,spatialReference:t})}(e,r,s),y=a.fromJSON(e.geometry);y.spatialReference=r;const m=function(e,{transformFieldRoles:t}){return new i({translation:[e[t.translationX],-e[t.translationZ],e[t.translationY]],rotationAxis:[e[t.rotationX],-e[t.rotationZ],e[t.rotationY]],rotationAngle:e[t.rotationDeg],scale:[e[t.scaleX],e[t.scaleZ],e[t.scaleY]]})}(e.attributes,s),p=r.isGeographic?"local":"georeferenced",h=d(f);return h?c.createWithExternalSource(g,h,{extent:y,transform:m,vertexSpace:p}):c.createIncomplete(g,{extent:y,transform:m,vertexSpace:p})}var p,h;function j(e,n){const r=new Map;for(const s of n){const n=s.parentGlobalId;if(null==n)continue;const a=s.assetName,l=s.assetType,u=s.assetHash,c=s.assetURL,i=s.conversionStatus,f=s.seqNo,g=y(l,e.supportedFormats);if(!g){t().error("mesh-feature-set:unknown-format",`Service returned an asset of type ${l}, but it does not list it as a supported type`);continue}const m=o(r,n,(()=>({files:new Map})));o(m.files,a,(()=>({name:a,type:l,mimeType:g,status:S(i),parts:[]}))).parts[f]={hash:u,url:c}}return r}function d(e){const t=Array.from(e.files.values()),n=new Array;for(const r of t){if(r.status!==p.COMPLETED)return null;const e=new Array;for(const t of r.parts){if(!t)return null;e.push(new f(t.url,t.hash))}n.push(new g(r.name,r.mimeType,e))}return n}function S(e){switch(e){case"COMPLETED":case"SUBMITTED":return p.COMPLETED;case"INPROGRESS":return p.PENDING;default:return p.FAILED}}(h=p||(p={}))[h.FAILED=0]="FAILED",h[h.PENDING=1]="PENDING",h[h.COMPLETED=2]="COMPLETED"}}}));
