System.register(["./index-legacy.js"],(function(n,e){"use strict";var t,r,a;return{setters:[n=>{t=n.ar,r=n.ec,a=n.ed}],execute:function(){function e(n){return Array.isArray(n)?n[0]?.spatialReference:n?.spatialReference}function i(n){return n?Array.isArray(n)?n.map(i):n.toJSON?n.toJSON():n:n}function c(n){return Array.isArray(n)?n.map((n=>r(n))):r(n)}let o;async function u(){return o||(o=a("geometryEngineWorker",{strategy:"distributed"})),o}async function s(n,e){return(await u()).invoke("executeGEOperation",{operation:n,parameters:i(e)})}async function f(n,e){const t=await u();return Promise.all(t.broadcast("executeGEOperation",{operation:n,parameters:i(e)}))}function l(n){return"xmin"in n?n.center:"x"in n?n:n.extent?.center}n({buffer:async function(n,t,r,a=!1){const i=[e(n),n,t,r,a];return c(await s("buffer",i))},changeDefaultSpatialReferenceTolerance:async function(n,e){await f("changeDefaultSpatialReferenceTolerance",[n,e])},clearDefaultSpatialReferenceTolerance:async function(n){await f("clearDefaultSpatialReferenceTolerance",[n])},clip:async function(n,t){return c(await s("clip",[e(n),n,t]))},contains:function(n,t){return s("contains",[e(n),n,t])},convexHull:async function(n,t=!1){return c(await s("convexHull",[e(n),n,t]))},crosses:function(n,t){return s("crosses",[e(n),n,t])},cut:async function(n,t){return c(await s("cut",[e(n),n,t]))},densify:async function(n,t,r){return c(await s("densify",[e(n),n,t,r]))},difference:async function(n,t){return c(await s("difference",[e(n),n,t]))},disjoint:function(n,t){return s("disjoint",[e(n),n,t])},distance:function(n,t,r){return s("distance",[e(n),n,t,r])},equals:function(n,t){return s("equals",[e(n),n,t])},extendedSpatialReferenceInfo:function(n){return s("extendedSpatialReferenceInfo",[n])},flipHorizontal:async function(n,e){if(null==n)throw new y;const t=n.spatialReference;if(null==(e=e??l(n)))throw new y;const r=n.constructor.fromJSON(await s("flipHorizontal",[t,n,e]));return r.spatialReference=t,r},flipVertical:async function(n,e){if(null==n)throw new y;const t=n.spatialReference;if(null==(e=e??l(n)))throw new y;const r=n.constructor.fromJSON(await s("flipVertical",[t,n,e]));return r.spatialReference=t,r},generalize:async function(n,t,r,a){return c(await s("generalize",[e(n),n,t,r,a]))},geodesicArea:function(n,t,r){return s("geodesicArea",[e(n),n,t,r])},geodesicBuffer:async function(n,t,r,a,i,o){const u=[e(n),n,t,r,a,i,o];return c(await s("geodesicBuffer",u))},geodesicDensify:async function(n,t,r,a=0){return c(await s("geodesicDensify",[e(n),n,t,r,a]))},geodesicLength:function(n,t,r){return s("geodesicLength",[e(n),n,t,r])},intersect:async function(n,t){return c(await s("intersect",[e(n),n,t]))},intersectLinesToPoints:async function(n,t){return c(await s("intersectLinesToPoints",[e(n),n,t]))},intersects:function(n,t){return s("intersects",[e(n),n,t])},isSimple:function(n){return s("isSimple",[e(n),n])},nearestCoordinate:async function(n,r,a=!0){const i=await s("nearestCoordinate",[e(n),n,r,a]);return{...i,coordinate:t.fromJSON(i.coordinate)}},nearestVertex:async function(n,r){const a=await s("nearestVertex",[e(n),n,r]);return{...a,coordinate:t.fromJSON(a.coordinate)}},nearestVertices:async function(n,r,a,i){return(await s("nearestVertices",[e(n),n,r,a,i])).map((n=>({...n,coordinate:t.fromJSON(n.coordinate)})))},offset:async function(n,t,r,a,i,o){return c(await s("offset",[e(n),n,t,r,a,i,o]))},overlaps:function(n,t){return s("overlaps",[e(n),n,t])},planarArea:function(n,t){return s("planarArea",[e(n),n,t])},planarLength:function(n,t){return s("planarLength",[e(n),n,t])},relate:function(n,t,r){return s("relate",[e(n),n,t,r])},rotate:async function(n,e,t){if(null==n)throw new y;const r=n.spatialReference;if(null==(t=t??l(n)))throw new y;const a=n.constructor.fromJSON(await s("rotate",[r,n,e,t]));return a.spatialReference=r,a},simplify:async function(n){return c(await s("simplify",[e(n),n]))},symmetricDifference:async function(n,t){return c(await s("symmetricDifference",[e(n),n,t]))},touches:function(n,t){return s("touches",[e(n),n,t])},union:async function(n,t=null){const r=function(n,e){let t;return Array.isArray(n)?t=n:(t=[],t.push(n),null!=e&&t.push(e)),t}(n,t);return c(await s("union",[e(r),r]))},within:function(n,t){return s("within",[e(n),n,t])}});class y extends Error{constructor(){super("Illegal Argument Exception")}}}}}));
